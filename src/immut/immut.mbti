package KCN-judu/linear-algebra/immut

alias @KCN-judu/linear-algebra/internal as @internal

// Values
fn identity[T : @internal.One + @internal.Zero](Int) -> Matrix[T]

// Types and methods
type Indexed[T]
impl Indexed {
  op_get[T](Self[T], Int) -> T
}

type Matrix[T]
impl Matrix {
  add_constant[T : @internal.Add](Self[T], T) -> Self[T]
  adjoint[T : @internal.Conjugate](Self[T]) -> Self[T]
  determinant[T : @internal.Mul + @internal.Add + @internal.One + @internal.Neg + @internal.Zero](Self[T]) -> T
  from_2d_array[T](Array[Array[T]]) -> Self[T]
  make[T](Int, Int, (Int, Int) -> T) -> Self[T]
  map[T, U](Self[T], (T) -> U) -> Self[U]
  new[T](Int, Int, T) -> Self[T]
  null[T : Compare + @internal.Zero](Self[T]) -> Bool
  op_add[T : @internal.Add](Self[T], Self[T]) -> Self[T]
  op_get[T](Self[T], Int) -> Indexed[T]
  op_mul[T : @internal.Mul + @internal.Add](Self[T], Self[T]) -> Self[T]
  op_neg[T : @internal.Neg](Self[T]) -> Self[T]
  op_sub[T : @internal.Add + @internal.Neg](Self[T], Self[T]) -> Self[T]
  scale[T : @internal.Mul](Self[T], T) -> Self[T]
  set[T](Self[T], Int, Int, T) -> Self[T]
  transpose[T](Self[T]) -> Self[T]
}
impl[T : Eq] Eq for Matrix[T]

type Vector[T]
impl Vector {
  from_array[T](Array[T]) -> Self[T]
  left_scale[T : @internal.Mul](Self[T], T) -> Self[T]
  length[T](Self[T]) -> Int
  lerp[T : @internal.One + @internal.Mul + @internal.Add + @internal.Neg](Self[T], Self[T], T) -> Self[T]
  make[T](Int, T) -> Self[T]
  makei[T](Int, (Int) -> T) -> Self[T]
  map[T, U](Self[T], (T) -> U) -> Self[U]
  op_add[T : @internal.Add](Self[T], Self[T]) -> Self[T]
  op_get[T](Self[T], Int) -> T
  op_mul[T : @internal.Mul](Self[T], Self[T]) -> Self[T]
  right_scale[T : @internal.Mul](Self[T], T) -> Self[T]
  scaled_matrix[T : @internal.Mul + @internal.Zero](Self[T]) -> Matrix[T]
  set[T](Self[T], Int, T) -> Self[T]
  tensor_product[T : @internal.Mul](Self[T], Self[T]) -> Matrix[T]
  zip_with[T, U, V](Self[T], Self[U], (T, U) -> V) -> Self[V]
}

// Type aliases

// Traits

